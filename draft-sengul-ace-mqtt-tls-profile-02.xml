<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
    which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
        <!-- One method to get references from the online citation libraries.
            There has to be one entity for each item to be referenced.
            An alternate method (rfc include) is described in the references. -->
	<!ENTITY RFC8174 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8174.xml">
        <!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
        <!ENTITY RFC2629 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2629.xml">
        <!ENTITY RFC4949 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4949.xml">
        <!ENTITY RFC6749 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6749.xml">
        <!ENTITY RFC7800 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7800.xml">
	]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs),
    please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
    (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
    (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="std" docName="draft-sengul-ace-mqtt-tls-profile-02" ipr="trust200902">
    <!-- category values: std, bcp, info, exp, and historic
       ipr values: trust200902, noModificationTrust200902, noDerivativesTrust200902,
          or pre5378Trust200902
       you can add the attributes updates="NNNN" and obsoletes="NNNN"
       they will automatically be output with "(if approved)" -->

    <!-- ***** FRONT MATTER ***** -->

    <front>
        <!-- The abbreviated title is used in the page header - it is only necessary if the
             full title is longer than 39 characters -->

        <title abbrev="MQTT-TLS profile of ACE">MQTT-TLS profile of ACE
        </title>

        <!-- add 'role="editor"' below for the editors if appropriate -->

        <!-- Author 1-->

        <author fullname="Cigdem Sengul" initials="C.S."
                surname="Sengul">
            <organization>Nominet</organization>

            <address>
                <postal>
                    <street>2 Kingdom Street</street>

                    <!-- Reorder these if your country does things differently -->

                    <city>London</city>

                    <code>W2 6BD</code>

                    <country>UK</country>
                </postal>

                <email>Cigdem.Sengul@nominet.uk</email>

                <!-- uri and facsimile elements may also be added -->
            </address>
        </author>

        <!-- Author 2-->

        <author fullname="Anthony Kirby" initials="A.K"
                surname="Kirby">
            <organization>Nominet</organization>

            <address>
                <postal>
                    <street>Minerva House, Edmund Halley Road</street>

                    <!-- Reorder these if your country does things differently -->

                    <city>Oxford</city>

                    <code>OX4 4DQ</code>

                    <country>UK</country>
                </postal>

                <email>Anthony.Kirby@nominet.uk</email>

            </address>
        </author>

	<!-- Author 3 -->
	<author fullname="Paul Fremantle" initials="P.F"
		surname="Fremantle">
	  <organization>University of Portsmouth</organization>
	  <address>
	    <postal>
	      <street>School of Computing, Buckingham House</street>
	      <city>Portsmouth</city>
	      <code>PO1 3HE</code>
	      <country>UK</country>
	    </postal>
	    <email>paul.fremantle@port.ac.uk</email>
	  </address>
	</author>  

        <date year="2018"/>

        <!-- If the month and year are both specified and are the current ones, xml2rfc will fill
             in the current day for you. If only the current year is specified, xml2rfc will fill
          in the current day and month for you. If the year is not the current one, it is
          necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the
          purpose of calculating the expiry date).  With drafts it is normally sufficient to
          specify just the year. -->

        <!-- Meta-data Declarations -->

        <area>Security</area>

        <workgroup>ACE Working Group</workgroup>

        <!-- WG name at the upperleft corner of the doc,
             IETF is fine for individual submissions.
          If this element is not present, the default is "Network Working Group",
             which is used by the RFC Editor as a nod to the history of the IETF. -->

        <keyword>Internet-Draft</keyword>


        <!-- Keywords will be incorporated into HTML output
             files in a meta tag but they have no effect on text or nroff
             output. If you submit your draft to the RFC Editor, the
             keywords will be used for the search engine. -->

        <abstract>
            <t>
                This document specifies a profile for the ACE (Authentication and Authorization for Constrained
                Environments) to enable
                authorization in an MQTT-based publish-subscribe messaging system.
                Proof-of-possession keys, bound to OAuth2.0 access tokens, are used to authenticate and authorize
                publisher and subscriber clients.
                The protocol relies on TLS for confidentiality and server authentication.
            </t>
        </abstract>
    </front>

    <middle>
        <section title="Introduction">
            <t>
                This document specifies a profile for the ACE framework <xref target="I-D.ietf-ace-oauth-authz"></xref>.
                In this profile, clients and a resource server use MQTT to communicate. The protocol relies on TLS for
                communication security between entities.
                The basic protocol interactions follow  <xref target="MQTT-OASIS-Standard">MQTT v3.1 - the OASIS Standard</xref>.
		In addition, this document describes improvements to the basic protocol with the new
		<xref target="MQTT-OASIS-Standard-v5">MQTT v5 - the OASIS Specification Draft</xref> (e.g., improved authentication
	        exchange and error reporting). Both versions are expected to be supported in practice, and therefore, covered
		in this document.
            </t>
            <t>
                MQTT is a publish-subscribe protocol and supports two types of client operation: publish and subscribe.
                Once connected,
                a client can publish to multiple topics, and subscribe to multiple topics; however, for the purpose of
                this document,
                these actions are described separately.
                The MQTT broker is responsible for distributing messages published by the publishers to the appropriate
                subscribers.
                Each publish message contains a topic, which is used by the broker to filter the subscribers for the
                message.
                Subscribers must subscribe to the topics to receive the corresponding messages.
            </t>
            <t>
                In this document, message topics are treated as resources.
                Clients use an access token, bound to a key (the proof-of-possession
                key) to authorize
                with the MQTT broker their connection and publish/subscribe permissions to topics. In the context
                of this ACE profile, the MQTT broker acts as the resource server.
                In order to provide communication confidentiality and resource server authentication, TLS is used.
            </t>
            <t>
                Clients use client authorization servers <xref
                    target="I-D.ietf-ace-actors"></xref> to obtain tokens
                from the authorization server. The communication protocol between the client authorization server and the
                authorization server is assumed to be HTTPS.
                Also, if the broker supports token introspection, it is assumed to use HTTPS to communicate with the
                authorization server.
                These interfaces MAY be implemented using other protocols e.g., CoAP or MQTT.
                This document makes the same assumptions as the Section 4 of
		<xref target="I-D.ietf-ace-oauth-authz">the
                ACE framework</xref> in terms of client and RS registration with the AS and establishing of keying material.
            </t>

            <t>This document describes authorization of the following exchanges between publisher and subscriber
                clients, and the broker.
            </t>
            <t>
                <list style="symbols">
                    <t>Connection establishment between the clients and the broker</t>
                    <t>Publish messages from the publishers to the broker, and from the broker to the subscribers</t>
                    <t>Subscribe messages from the subscribers to the broker</t>
                </list>
            </t>
	    <t>
	      In <xref target="basic-protocol"></xref>, these exchanges are described based on the
	      <xref target="MQTT-OASIS-Standard">MQTT v3.1 - the OASIS Standard</xref>. These exchanges are also supported by the
	      new <xref target="MQTT-OASIS-Standard-v5">MQTT v5 - the OASIS Specification Draft</xref>. 
	      <xref target="MQTTv5"></xref> describes how they 
	      may be improved by the new MQTT v5. 
	    </t>

            <section title="Requirements Language">
                <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
                    "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",  "MAY", and "OPTIONAL" in this
                    document are to be interpreted as described in BCP 14 <xref target="RFC2119"></xref> <xref target="RFC8174"></xref>, when, and only when, they appear in all capitals, as shown here.
                </t>
            </section>

            <section title="ACE-Related Terminology">
                <t>
                    The terminology for entities in the architecture is defined in OAuth 2.0 <xref target="RFC6749">RFC
                    6749
                </xref> and <xref target="I-D.ietf-ace-actors">ACE actors</xref>, such as "Client" (C), "Resource
                    Server" (RS) and "Authorization Server" (AS).
                </t>
                <t>
                    The term "endpoint" is used following its OAuth definition, to denote resources such as /token and
                    /introspect at the AS.
                </t>
                <t>
                    The term "Resource" is used to refer to an MQTT "topic", which is defined in Section 1.2.
                    Hence, the "Resource Owner" is any entity that can authoritatively speak for the "topic".
                </t>
                <t>
                    Certain security-related terms such as "authentication", "authorization", "confidentiality", "(data)
                    integrity",
                    "message authentication code", and "verify" are taken from  <xref target="RFC4949">RFC 4949</xref>.
                </t>
            </section>

            <section title="MQTT-Related Terminology">
                <t>
                    The document describes message exchanges as MQTT protocol interactions. For additional information,
                    please refer to the <xref target="MQTT-OASIS-Standard">MQTT v3.1 - the OASIS Standard</xref> or the
		    <xref target="MQTT-OASIS-Standard-v5">MQTT v5 - the OASIS Specification Draft</xref>.
                </t>
                <t>
                    <list hangIndent="8" style="hanging">
                        <t hangText="Topic name">
                            <vspace blankLines="0"/>
                            The label attached to an application message, which is matched to a subscription.
                        </t>
                        <t hangText="Topic filter">
                            <vspace blankLines="0"/>
                            An expression that indicates interest in one or more topic names. Topic filters may include
                            wildcards.
                        </t>
                        <t hangText="Subscription">
                            <vspace blankLines="0"/>
                            A subscription comprises a Topic filter and a maximum quality of service (QoS).
                        </t>
                        <t hangText="Application Message">
                            <vspace blankLines="0"/>
                            The data carried by the MQTT protocol. The data has an associated QoS level and a Topic
                            name.
                        </t>
                    </list>
                </t>
                <t>
                    MQTT sends various control messages across a network connection.
                    The following is not an exhaustive list and the control packets that are not relevant for
                    authorization are not explained.
                    These include, for instance, the PUBREL and PUBCOMP packets used in the 4-step handshake required
                    for the QoS level 2.

                    <list hangIndent="8" style="hanging">
                        <t hangText="CONNECT">
                            <vspace blankLines="0"/>
                            Client request to connect to the broker. After a network connection is established, this is
                            the first packet sent by a client.
                        </t>
                        <t hangText="CONNACK">
                            <vspace blankLines="0"/>
                            The broker connection acknowledgment. The first packet sent from the broker to a client is a
                            CONNACK packet. CONNACK packets
                            contain return codes indicating either a success or an error state to a client.
                        </t>
                        <t hangText="PUBLISH">
                            <vspace blankLines="0"/>
                            Publish packet that can be sent from a client to the broker, or from the broker to a
                            client.
                        </t>
                        <t hangText="PUBACK">
                            <vspace blankLines="0"/>
                            Response to PUBLISH packet with QoS level 1. PUBACK can be sent from the broker to a
                            client or a client to the broker.
                        </t>
                        <t hangText="PUBREC">
                            <vspace blankLines="0"/>
                            Response to PUBLISH packet with QoS level 2. PUBREC can be sent from the broker to a
                            client or a client to the broker.
                        </t>
                        <t hangText="SUBSCRIBE">
                            <vspace blankLines="0"/>
                            The client subscribe request.
                        </t>
                        <t hangText="SUBACK">
                            <vspace blankLines="0"/>
                            Subscribe acknowledgment.
                        </t>
			<t hangText="PINGREQ">
			  A ping request sent from a client to the broker.  It signals to the broker that the client is alive, and
			  is used to confirm that the broker is still alive.  
			</t>
                    </list>
                </t>
            </section>

        </section>

        <section title="Basic Protocol Interactions" anchor="basic-protocol">
          <t> This section describes the following exchanges between publisher and subscriber clients, the broker, and
	  the authorization server according to the <xref target="MQTT-OASIS-Standard">MQTT v3.1 - the OASIS Standard</xref>.
	  These exchanges are compatible also with the new <xref target="MQTT-OASIS-Standard-v5">MQTT v5 - the OASIS Specification
	  Draft</xref>. In addition,  <xref target="MQTTv5"></xref> describes how these exchanges may be improved with the
	  MQTT v5.  
            </t>
            <t>
                <list style="symbols">
                    <t>Authorizing connection establishment between the clients and the broker</t>
                    <t>Authorizing publish messages from the publishers to the broker, and from the broker to the
                        subscribers
                    </t>
                    <t>Authorizing subscribe messages from the subscribers to the broker</t>
                </list>
            </t>
            <t>
                Message topics are treated as resources.
                The publisher and subscriber clients are assumed to have identified the topics of interest out-of-band
                (topic discovery is not a feature of the MQTT protocol).
            </t>
            <t>
                A connection request carries a token specifying the permissions that the client has (e.g., publish
                permission to a given topic).
                A resource owner can pre-configure policies at the AS that give clients publish or subscribe
                permissions to different topics.
            </t>

            <section title="Authorizing Connection Establishment" anchor="token_acquisition">
                <t>
                    This section specifies how publishers and subscribers establish an authorized connection to an MQTT
                    broker. The token request and response
                    use the /token endpoint of the authorization server, as specified in Section 6 of the <xref
                        target="I-D.ietf-ace-oauth-authz">ACE framework</xref>.
                </t>
                <t>
                    <xref target="basic_protocol_flow"></xref> shows the basic protocol flow during connection
                    establishment.
                </t>
                <figure align="center" anchor="basic_protocol_flow" title="Connection establishment">
                    <artwork align="left"><![CDATA[
                            +----------------+
   +---(A) Token request----| Client         |
   |                        | Authorization  |
   |   +-(B) Access token-->| Server         |
   |   |                    |________________|
   |   |                            |
   |   |                (C) Client On-boarding
   |   |                            |
   |   |                  +---------v-----+
+--v-------------+        | Publisher or  |
|                |        | Subscriber    |
|  Authorization |        |_______________|
|  Server        |            |       ^
|________________|            |       |
   |    ^             (D)Connection  (G)Connection
   |    |               request +    response
   |    |               access token  |
   |    |                     |       |
   |    |                 +---v--------------+
   |    |                 |   Broker         |
   |    +(E)Introspection-| Resource Server  |
   |     request          |                  |
   +-(F)Introspection---->|__________________|
        response
           ]]></artwork>
                </figure>

                <section title="Client Authorization Server (CAS) and Authorization Server (AS) Interaction">
                    <t>
                        The first step in the protocol flow (Figure 1 (A)) is token acquisition by the client authorization server
                        (CAS) from the AS.
                        If a client has enough resources and can support HTTPS, or optionally the AS supports MQTTS,
                        these steps can instead be carried out
                        by a client directly.
                    </t>
                    <t>
                        When requesting an access token from the AS, the CAS MAY include parameters in its request as
                        defined in Section 6.1
                        of <xref target="I-D.ietf-ace-oauth-authz">the ACE framework</xref>. The content type is set to
                        "application/json". The profile name is 'mqtt_tls'.
                    </t>
                    <t>
                        If the access token request has been successfully verified by the AS and the client is
                        authorized to obtain a token for the
                        indicated audience (e.g., topics) and scopes (e.g., publish/subscribe permissions),
                        the AS issues an access token (Figure 1 (B)). 
                        The response includes the parameters described in Section 6.2 of <xref
                            target="I-D.ietf-ace-oauth-authz">the ACE framework</xref>.  
			This includes a token, which is assumed to be PoP by default. Hence,  a 'cnf' parameter with a
			symmetric or asymmetric PoP key is returned. The token may be a reference, or a CBOR or JWT web token.
			Note that the 'cnf' parameter in the web tokens
                        are to be consumed by the resource server and not the client.  For more information on Proof of Possession semantics in JWTs
			see <xref target="RFC7800">RFC 7800</xref> and for CWTs, 
			see <xref target="I-D.ietf-ace-cwt-proof-of-possession">Proof-of-Possession Key Semantics for CBOR Web Tokens (CWTs)</xref>. 
                    </t>
                    <t>
                        In the case of an error, the AS returns error responses for HTTP-based interactions as ASCII
                        codes in JSON content, as defined in Section 5.2 of <xref target="RFC6749">RFC 6749</xref>.
                    </t>
                </section>
                <section title="Client connection request to the broker" anchor="connect_v31">
                  <t>
		        Client on-boarding (Figure 1 (C)) is out of the scope of this document.
                        Once the client acquires the token, it can use it to request an MQTT connection to the broker
                        over a TLS session with server authentication (Figure 1 (D)). 
                        This section describes the client transporting the token to the broker (RS) via the CONNECT
                        control message after the TLS handshake. This is similar to an earlier proposal by Fremantle et 
                        al. <xref target="fremantle14"></xref>. An improvement to this is presented in  <xref target="MQTTv5"></xref>
                        for the <xref target="MQTT-OASIS-Standard-v5">MQTT v5 - the OASIS Specification Draft</xref>.
                        Alternatively, the token may be used for the TLS session establishment as described in
                        the <xref target="I-D.gerdes-ace-dtls-authorize">DTLS profile for ACE</xref>. In this case, both
                        the TLS PSK and RPK handshakes MAY be supported.
                        This may additionally require that the client transports the token to the broker before the
                        connection establishment.
                        To this end, the broker MAY support /authz-info endpoint via the "authz-info" topic.
			Then, to transport the token, clients publish to "authz-info" topic unauthorized.  The topic
			"authz-info" MUST be publish-only for clients (i.e., the clients are not allowed to subscribe to it).
                        This option is described in more detail in 
                        <xref target="app-authzinfo"></xref>.
                    </t>

                    <t>
                        When the client wishes to connect to the broker, it uses the CONNECT message of MQTT.
                        <xref target="mqtt_connect_message"></xref>
                        shows the structure of the MQTT CONNECT control message.
                    </t>
                    <figure align="center" anchor="mqtt_connect_message"
                            title="MQTT CONNECT control message. (CPT=Control Packet Type, Rsvd=Reserved, len.=length, Proto.=Protocol)">
                        <artwork align="left"><![CDATA[
       0            8            16            24            32
       +------------------------------------------------------+
       |CPT=1 | Rsvd.|Remaining len.| Protocol  name len. = 4 |
       +------------------------------------------------------+
       |                      'M' 'Q' 'T' 'T'                 |
       +------------------------------------------------------+
       | Proto.level=4|Connect flags|          Keep alive     |
       +------------------------------------------------------+
       |         Payload including User Name (='token')       |
       |     Password length and data (=signature/MAC)        |
       |                           ...                        |
       +------------------------------------------------------+
        ]]></artwork>
                    </figure>
                    <t>
                        To communicate the necessary connection parameters, the Client uses the appropriate flags of the
                        CONNECT message.
                        <xref target="mqtt_connect_flags"></xref>
                        shows how the MQTT connect flags MUST be set to initiate a connection with the broker.
                    </t>
                    <figure align="center" anchor="mqtt_connect_flags" title="MQTT CONNECT flags. (Rsvd=Reserved)">
                        <artwork align="left"><![CDATA[
+-----------------------------------------------------------+
|User name|Pass.|Will retain|Will QoS|Will Flag|Clean| Rsvd.|
| flag    |flag |           |        |         |     |      |
+-----------------------------------------------------------+
| 1       | 1   |    X      |   X X  |   X     |  1   |  0  |
+-----------------------------------------------------------+
         ]]></artwork>
                    </figure>
                    <t>
                        In order to ensure that the client and the broker discard any previous session and start a new
                        session, the Clean Session Flag MUST be set to 1.
                    </t>
                    <t>
                        The Will flag indicates that a Will message needs to be sent when a client disconnection occurs.
                        The situations in which the Will message
                        is published include disconnections due to I/O or network failures, and the server closing the
                        networking connection due to a protocol error.
                        The client may set the Will flag as desired (marked as 'X' in <xref
                            target="mqtt_connect_flags"></xref>).
                        If the Will flag is set to 1 and the broker accepts the connection request, the broker must
                        store the Will message, and  publish it when the network connection is closed according to Will QoS and
			Will retain parameters, and MQTT Will management rules.
                         <xref target="disconnections"></xref>
                        explains how the broker deals with the retained messages in further detail.
                    </t>
                    <t>
                        Finally, Username and Password flags MUST be set to 1 to  ensure that the Payload of the
                        CONNECT message includes both Username and Password fields.
                    </t>
                    <t>
                        The CONNECT message defaults to ACE for authentication and authorization.
                        For the basic operation described in this section, the Username field MUST be set to the token.
                        The Password field MUST be set to the keyed message digest (MAC) or signature.
                        The client MAY apply  the PoP key either to the token or the entire request by computing a keyed message digest
   			(for symmetric key) or a digital signature (for asymmetric key).
			<!--In addition, <xref target="MQTTv5"></xref>
			describes request-response protocol, which is possible under MQTT v5 and enables 
			the RS to send a challenge to the client. -->
                        (The Username field is a UTF-8 encoded string, which is prefixed with a two-byte length field
			and can have any length 
                         in the range of 0 and 65535. Similarly, the password field contains 0 to 65535 bytes of binary data, 
			 prefixed by a two-byte length field.)
                    </t>

                </section>
                <section title="Token validation" anchor="token_validation">
                    <t>
                        RS MUST verify the validity of the token.
                        This validation MAY be done locally (e.g., in the case of a self-contained token) or the RS MAY send an introspection request to the AS.
                        If introspection is used, this section follows similar steps to those described in Sections 7.2
                        and 7.3 of <xref target="I-D.ietf-ace-oauth-authz">the ACE framework</xref>.
                        The communication between AS and RS MAY be HTTPS, but it, in every case, MUST be confidential,
                        mutually authenticated and integrity protected.
                    </t>
                    <t>
                        The broker MUST check if the token is
                        active either using 'expires_in' parameter of the token or 'active'
                        parameter of the introspection response.
                    </t>
                    <t>
                        The access token is constructed by the AS such that RS can associate the access token with
                        the client key.
                        This document assumes that the Access Token is a PoP token as
                        described in <xref target="I-D.ietf-ace-oauth-authz"></xref>.
                        Therefore, the necessary information is contained in the 'cnf' claim of the access token and
                        may use either public or shared key
                        approaches.
                        The client uses the signature or the MAC  in the password field to prove the possession of the key.
                        Depending on the chosen implementation, the resource server validates the signature or the MAC
                        over the token or the contents of the packet, authenticating the client.
                    </t>
                    <t>
                        The broker uses the scope field in the token (or in the introspection result) to determine the publish and
                        subscribe permissions for the client. If the Will flag is set,
			then the broker MUST check that the token allows the publication of the
                        Will message too.
		    </t>	
			
                    <t>
                        The broker MAY cache the introspection result because it will need to decide whether to accept
                        subsequent PUBLISH and SUBSCRIBE messages and
                        these messages, which are sent after a connection is set-up, do not contain tokens.
                        If the introspection result is not cached, then the RS needs to introspect the saved token for
                        each request.
                    </t>
		    <t>
                Note: Scope strings MAY follow an application specific convention. One option is to encode
                the permission and the topics it applies to the scope string e.g., 'publish_topic1' or 'subscribe_topic2'.
		      A second option is to simply use the keywords 'publish' or 'subscribe' as scope strings and use the 'aud'
		      field to define the topic. Another option is to use topic names as scope strings and use the 'aud' field
		      to define whether the 'publish' or 'subscribe' permission applies to these scopes.
		      The choice is left to the implementer and depends on how the following trade-off is expected to be handled:
		      token simplicity versus the number of tokens the broker is expected to handle per client.
		    </t>  
                </section>
                <section title="The broker's response to client connection request">
                    <t>
                        Based on the validation result (obtained either via local inspection or using the /introspection
                        interface of the AS), the broker MUST send a CONNACK message to the client.
                    </t>
                    <t>
                        The broker responses may follow either the <xref target="MQTT-OASIS-Standard">MQTT v3.1 - the OASIS Standard</xref> or the
		    <xref target="MQTT-OASIS-Standard-v5">MQTT v5 - the OASIS Specification Draft</xref>, depending on which version(s) the broker supports.
                    </t>
		    <t>
                      In <xref target="MQTT-OASIS-Standard">MQTT v3.1 - the OASIS Standard</xref>, it is not possible to support AS discovery via sending a tokenless
		      CONNECT message to the broker.
                        This is because a CONNACK packet does not include a means to provide additional information to the client.
			Therefore, AS discovery needs to take place out-of-band. This is remedied in the <xref target="MQTT-OASIS-Standard-v5">MQTT v5 - the OASIS Specification
			Draft</xref> and a solution is described in <xref target="MQTTv5"></xref>.
                    </t>
                    <t>
                        If the RS accepts the connection, it MUST store the token.
                    </t>
                </section>
            </section>
            <section title="Authorizing PUBLISH messages">
               
                <section title="PUBLISH messages from the publisher client to the broker">
                    <t>
                        On receiving the PUBLISH message, the broker MUST use the type of
                        message (i.e., PUBLISH) and the topic name in the message header to compare against the
                        cached token or its introspection result (depending on the implementation, different fields of the token or the introspection
			result may be checked, see the Note in <xref target="token_validation"></xref>).
                    </t>
                    <t>
                       If the client is allowed to publish to the topic, the RS must publish the message to all valid subscribers of the topic. The broker
		       may also return an acknowledgment
                        message if the QoS level is greater than or equal to 1. 
		    </t>	
		     <t>	
		       In case of a failure,  it is not possible to return an error in <xref target="MQTT-OASIS-Standard">MQTT v3.1 - the OASIS Standard</xref>.
		       The return of acknowledgement messages only indicates success. In the case of an authorization error, the broker SHOULD disconnect the client.
		       Otherwise, it
                        MUST ignore the PUBLISH message. Also, 
                        DISCONNECT messages are only sent from a client to the broker. So, server disconnection
                        needs to take place below the application layer. However, in <xref target="MQTT-OASIS-Standard-v5">MQTT v5 - the OASIS Specification
			Draft</xref>, it is possible to indicate failure and provide a reason code. <xref target="MQTTv5"></xref> describes in more detail how
			PUBLISH authorization errors are handled.   
                    </t>
                    
                </section>
                <section title="PUBLISH messages from the broker to the subscriber clients">
                    <t>To forward PUBLISH messages to the subscribing clients, the broker identifies all the
                        subscribers that have matching valid topic subscriptions (i.e., the tokens are valid and
                        token scopes allow a subscription to the particular topic name).
                        The broker sends a PUBLISH message with the topic name and the topic message to all the valid
                        subscribers.
                    </t>

                    <t>
                        In MQTT, after connection establishment, there is no way to inform a client that an
                        authorization error has occurred for previously subscribed topics, e.g., token expiry.
                        In the case of an authorization error, the broker has two options: (1) stop forwarding
                        PUBLISH messages to the unauthorized client or (2) disconnect the client.
                        In the <xref target="MQTT-OASIS-Standard">MQTT v3.1 - the OASIS Standard</xref>, the MQTT
                        DISCONNECT messages are only sent from a client to the broker.
                        Therefore, the server disconnection needs to take place below the application layer.
			In <xref target="MQTT-OASIS-Standard-v5">MQTT v5 - the OASIS Specification
			Draft</xref>, a server-side DISCONNECT message is possible and described in <xref target="MQTTv5"></xref>. 
			
                    </t>
                </section>
            </section>
            <section title="Authorizing SUBSCRIBE messages">
                <t>In MQTT, a SUBSCRIBE message is sent from a client to the broker to create one or more subscriptions
                    to one or more topics.
                    The SUBSCRIBE message may contain multiple topic filters.
                    The topic filters may include wildcard characters.
                </t>
                <t>
                    On receiving the SUBSCRIBE message, the broker MUST use the type of message (i.e.,
                    SUBSCRIBE) and the topic filter in the message header to compare
                    against the stored token or introspection result (depending on the implementation, different fields of the token or introspection
		    result may be checked, see the Note in <xref target="token_validation"></xref>).
                </t>
                <t>
                    As a response to the SUBSCRIBE message, the broker issues a SUBACK message. For each topic filter,
                    the SUBACK packet includes a return code matching the QoS level
                    for the corresponding topic filter. In the case of failure, the return code, in MQTT v3.1,  must be 0x80 indicating 'Failure'.
                    In MQTT v5, the appropriate return code is 0x87, indicating that the client is 'Not authorized'. Note that, in both MQTT versions,
		    a reason code is returned for each topic filter. Therefore, the client may receive success codes for a subset of its topic filters, while being
		    unauthorized for the rest. 
                </t>
            </section>
            <section title="Token expiration">
                <t>
                    The broker MUST check for token expiration whenever a CONNECT, PUBLISH or SUBSCRIBE message is received
                    or sent. The broker SHOULD check for token expiration on receiving a PINGREQUEST message. This may allow
		    for early detection of a token expiry. 
		</t>
		 <t>     
                    The token validation is done either by checking the 'exp' claim of a CWT/JWT or via performing an
                    introspection request with the Authorization server as described in Section 8.2 of <xref
                        target="I-D.ietf-ace-oauth-authz">the ACE framework</xref>.
                    In the basic operation, token expirations MAY lead to disconnecting the associated client.
		    However, in <xref target="MQTT-OASIS-Standard-v5">MQTT v5 - the OASIS Specification
		    Draft</xref>, better error handling and re-authentication are possible.
		    This is explained in more detail in <xref target="MQTTv5"></xref>.   
                </t>
            </section>
            <section title="Handling disconnections and retained messages" anchor="disconnections">
                <t>
                    According to <xref target="MQTT-OASIS-Standard">MQTT v3.1 - the OASIS Standard</xref>, only Client
                    DISCONNECT messages are allowed. In <xref target="MQTT-OASIS-Standard-v5">MQTT v5 - the OASIS Specification
                        Draft</xref>,  server-side DISCONNECT messages are possible, allowing to return '0x87 Not Authorized' return code
                    to the client.
                 </t>
                 <t>
                    In the case of a DISCONNECT, due to the Clean Session flag, the broker
                    deletes all session state but MUST keep the retained messages.
                    By setting a RETAIN flag in a PUBLISH message
                    the publisher indicates to the broker that it should store the most
                    recent message for the associated topic.  Hence, the new subscribers can receive
                    the last sent message from the publisher for that particular topic without waiting for the next PUBLISH message.
                    In the case of a disconnection, the broker MUST continue publishing
                    the retained messages as long as the associated tokens are valid.
                </t>
                <t>
                    In case of disconnections due to network errors or server disconnection due to a protocol error
                    (which includes authorization errors), the Will message must be sent if the client supplied
                    a Will in the CONNECT request message.  The token provided in the CONNECT request must cover the Will topic.
                    The Will message MUST be published to the Will topic when the network connection is closed regardless of whether the corresponding
		    token has expired.
                </t>
            </section>
        </section>

	<section anchor="MQTTv5" title="Improved Protocol Interactions with MQTT v5">
	   <t>
	    In the new <xref target="MQTT-OASIS-Standard-v5">MQTT v5 - the OASIS Specification
            Draft</xref>, several new capabilities are introduced, which enable better integration with the ACE standards.
	    The newly enhanced authentication and re-authentication methods support a much wider range of authentication flows
	    beyond username and password. With the MQTT v5, there is a 
	    clearly defined approach for using token-based approaches. Similarly, in MQTT v5, it is possible for a client to request a re-authentication.
	    Finally, MQTT v5 generally improves error reporting, enabling better response to authorization failures during
	    publishing messages to the subscribers.   
	  </t>  

	  <section anchor="token_transport_v5" title="Token Transport via Authentication Exchange (AUTH)">  
	    <t>
	      To initiate the authentication and authorization flow, 
	      as before, the CAS initiates the token request as in  <xref target="token_acquisition"></xref>.
              When the client wishes to connect to the RS (broker), it uses the CONNECT message of MQTT.
	       <xref target="mqtt5_connect_message"></xref>
                 shows the structure of the MQTT CONNECT control message used in MQTT v5.
	    </t>
	    
	    <figure align="center" anchor="mqtt5_connect_message"
                            title="MQTT CONNECT control message. (CPT=Control Packet Type, Rsvd=Reserved, len.=length, Proto.=Protocol)">
             <artwork align="left"><![CDATA[
       0            8            16            24            32
       +------------------------------------------------------+
       |CPT=1 | Rsvd.|Remaining len.| Protocol  name len. = 4 |
       +------------------------------------------------------+
       |                      'M' 'Q' 'T' 'T'                 |
       +------------------------------------------------------+
       | Proto.level=5|Connect flags|          Keep alive     |
       +------------------------------------------------------+
       |                 Property length                      |
       | 	      Auth. Method (0x15) | 'ace_mqtt_tls'    |
       |          Auth. Data (0x16)   | empty or token        | 
       |                                                      |
       +------------------------------------------------------+
        ]]></artwork>
            </figure>

	    <t>
	       To communicate the necessary connection parameters, the client uses the appropriate flags of the
               CONNECT message. 
	       To achieve a clean session (i.e., the session should start without an existing session), the new MQTT v5
	       session flags MUST be set appropriately: the Clean Start Flag MUST be set to 1
	       and Session Expiry Interval MUST be set to 0.
	    </t>

	    <t>
	       With the enhanced authentication capabilities, it is not necessary to overload the username and password fields
	      in the CONNECT message for ACE authentication. 
	      Nevertheless, the RS MUST support both methods for supporting the token: (1) Token transport via
	      username and password and (2) using the new AUTH (Authentication Exchange) method.
	      The token transport via username and password is as described in <xref target="connect_v31"></xref>.
	      The rest of this section describes the AUTH method.
	    </t>
	    
	    <t>
	        To use the AUTH method, the username flag MUST be set to 0 and the password flag MUST be set to 0. 
		The client can set the Authentication Method as a property of a CONNECT packet by setting
		Auth Properties (with the property identifier 0x15).
	        The client must MUST set the UTF-8 encoded string containing the name of the
		authentication method as 'ace_mqtt_tls'. If the RS does not support this profile, it sends a CONNACK with a
		Reason Code of '0x8C (Bad authentication method)'
	    </t>

	    <t>
	      The Authentication Method is followed by the Authentication Data, which has a property identifier 0x16.
	      Authentication data is binary data and is defined by  the authentication method. The RS MAY support different
	      implementations for transporting the authentication data. The first option is that Authentication data contains both the token and
	      the keyed message digest (MAC) or signature as described in <xref target="connect_v31"></xref>.
	      In this case, the token validation proceeds as described in <xref target="token_validation"></xref> and the
	      server responds with a CONNACK.  The reason code of the CONNACK '0x00 (Success)' if the authentication is successful.
	      In case of an invalid PoP token, the CONNACK reason code is '0x87 (Not Authorized)'.
	    </t>

	    <t>
	      The second option that RS may accept is a challenge/response protocol. If the Authentication Data only
	      includes the token, the RS MUST respond with an AUTH packet, with the Authenticate Reason Code  set to
	      '0x18 (Continue Authentication)'. This packet includes the Authentication Method, which MUST be set to
	      'ace_mqtt_tls' and Authentication Data. The Authentication Data MUST NOT be empty and contains 
	      a challenge for the client. The client responds to this with an AUTH packet, with a reason code  
	      '0x18 (Continue Authentication)'. Similarly, the client packet sets the Authentication Method to 'ace_mqtt_tls'.
	      The Authentication Data in the client's response contains the signature or MAC computed over the RS's challenge.
	      To this, the server responds with a CONNACK and a return code of '0x00 (Success)' if the authentication is successful.
	      In case of an invalid PoP token, the CONNACK reason code is '0x87 (Not Authorized)'.
	    </t>

	    <t>
	      Finally, this document allows the CONNECT message to have an empty Authentication Data field. This is the AS discovery option
	      and the RS responds with a CONNACK reason code '0x87 (Not Authorized)' and includes a User Property set to the address
	      of the AS. 
	    </t>

	    
	  </section>
	  <section anchor="improved_error_messaging" title="Authorization Errors and Client Re-authentication">
	    <t>
              MQTT v5 allows better error reporting. To take advantage of this for PUBLISH messages, the QoS level should be set to
	      greater than or equal to 1. This guarantees that RS responds with either a PUBACK or PUBREC packet with a reason code
	      '0x87 (Not authorized)' in the case of an authorization error.
	      Similarly, for the SUBSCRIBE case,  the  SUBACK packet will have a reason code set to
	      '0x87 (Not authorized)' for the unauthorized topic(s).
	      When RS is forwarding PUBLISH messages to the subscribed clients, it may discover that some of the subscribers are
	      no more authorized due to expired tokens.
	      In this case, the RS SHOULD send a DISCONNECT message with the reason code '0x87 (Not authorized)'. Note that
	      the server-side DISCONNECT is a new feature of MQTT v5 (in MQTT v3.1
	      server needed to drop the connection).
	      RS MUST stop forwarding messages to the unauthorized subscribers. 
	    </t>

	    <t>
	      In the case of a PUBACK with '0x87 (Not authorized)', the client can update its token using the Re-authentication feature of
	      MQTT v5.  Also, the clients can proactively update their tokens without waiting for such a PUBACK.
	      To re-authenticate, the client sends an AUTH packet with a reason code '0x19 (Re-authentication)'. The client MUST
	      set the authentication method as 'ace_mqtt_tls' and transport the new token in the Authentication Data.
	      The client and the RS go through the same steps for proof of possession validation described in the previous section.
	      If the re-authentication fails, the server
	      MUST send a DISCONNECT with the reason code '0x87 (Not Authorized)'. 
	    </t>
	  </section>  
	</section>
        
	<!-- This PI places the pagebreak correctly (before the section title) in the text output. -->

        <!--<?rfc needLines="8" ?>-->

        <!-- Possibly a 'Acknowledgements'/ 'Contributors' section ... -->
        <section anchor="IANA" title="IANA Considerations">
            <t>This memo includes no request to IANA.</t>
        </section>

        <section anchor="Security" title="Security Considerations">
            <t> The security considerations outlined in <xref target="I-D.ietf-ace-oauth-authz"></xref> apply to this work.</t>
        </section>

        <section anchor="Privacy" title="Privacy Considerations">
          <t>The privacy considerations outlined in <xref target="I-D.ietf-ace-oauth-authz"></xref> apply to this work.
          Furthermore, the RS is a central trusted party and may forward potentially sensitive information
	  between clients. 
	  </t>
        </section>


    </middle>


    <!--  *****BACK MATTER ***** -->

    <back>
        <!-- References split into informative and normative -->

        <!-- There are 2 ways to insert reference entries from the citation libraries:
         1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
         2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
            (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

         Both are cited textually in the same manner: by using xref elements.
         If you use the PI option, xml2rfc will, by default, try to find included files in the same
         directory as the including file. You can also define the XML_LIBRARY environment variable
         with a value containing a set of directories to search.  These can be either in the local
         filing system or remote ones accessed by http (http://domain/dir/... ).-->

        <references title="Normative References">
            <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->
            &RFC2119;
	    &RFC8174;
            <reference anchor="MQTT-OASIS-Standard"
                       target="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/mqtt-v3.1.1.html">
                <front>
                    <title>
                        OASIS Standard MQTT Version 3.1.1 Plus Errata 01
                    </title>
                    <author initials="A." surname="Banks" role="editor">
                        <organization>IBM</organization>
                    </author>
                    <author initials="R." surname="Gupta" role="editor">
                        <organization>IBM</organization>
                    </author>
                    <date year="2015"/>
                </front>
            </reference>

	    <reference anchor="MQTT-OASIS-Standard-v5"
		       target="http://docs.oasis-open.org/mqtt/mqtt/v5.0/csprd01/mqtt-v5.0-csprd01.html">
	       <front>
		 <title>
		   OASIS Public Review Draft 01 MQTT Version 5.0
		 </title>
		 <author initials="A." surname="Banks" role="editor">
		   <organization>IBM</organization>
		 </author>
		 <author initials="E." surname="Briggs" role="editor">
		   <organization>Microsoft</organization>
		 </author>
		 <author initials="K." surname="Borgendale" role="editor">
		   <organization>IBM</organization>
		 </author>
		 <author initials="R." surname="Gupta" role="editor">
                   <organization>IBM</organization>
                 </author>
		 <date year="2017"/>
 	       </front>   
	    </reference>

            <?rfc include="reference.I-D.ietf-ace-oauth-authz.xml"?>

            <?rfc include="reference.I-D.gerdes-ace-dtls-authorize.xml"?>

        </references>

        <references title="Informative References">
            <!-- Here we use entities that we defined at the beginning. -->
            <!-- A reference written by by an organization not a person. -->

            <?rfc include="reference.I-D.ietf-ace-actors.xml"?>
	    <?rfc include="reference.I-D.ietf-ace-cwt-proof-of-possession.xml"?>
            &RFC4949;
            &RFC6749;
	    &RFC7800;
	    <reference anchor="fremantle14" target="http://dx.doi.org/10.1109/SIoT.2014.8">
		<front>
			<title> 
				Federated Identity and Access Management for the Internet of Things
			</title>
			<author initials="P." surname="Fremantle"></author>
			<author initials="B." surname="Aziz"></author>
			<author initials="J." surname="Kopecky"></author>
			<author initials="P." surname="Scott"></author>
			<date month="September" year="2014"></date>			
		</front>
		<seriesInfo name="research" value="International Workshop on Secure Internet of Things"></seriesInfo>
	    </reference>	
        </references>

        <section anchor="app-profile-requirements" title="Checklist for profile requirements">
            <t>
                <list style="symbols">
                  <t>AS discovery: For the basic protocol using either MQTT v3.1 or MQTT v5,  the clients/client authorization servers need to be
		  configured out-of-band. RS does not provide any hints
                  to help AS discovery.
		   AS discovery is possible with the MQTT v5 extensions described in <xref target="MQTTv5"></xref>.
                    </t>
                    <t>The communication protocol between the client and RS: MQTT</t>
                    <t>The security protocol between the client and RS: TLS</t>
                    <t>Client and RS mutual authentication: RS provides a server certificate during TLS handshake. Client
                        transports token and MAC via  the MQTT
                        CONNECT message.
                    </t>
                    <t>Content format: For the HTTPS interactions with AS, "application/json".  The MQTT payloads may be
                        formatted
                        JSON or CBOR.
                    </t>
                    <t>PoP protocols: Either symmetric or asymmetric keys can be supported.</t>
                    <t>Unique profile identifier: mqtt_tls</t>
                    <t>Token introspection: RS uses HTTPS /introspect interface of AS.</t>
                    <t>Token request: CAS uses HTTPS /token interface of AS.</t>
                    <t>/authz-info endpoint: It MAY be supported using the method described in <xref
                            target="app-authzinfo"></xref>,
                        not protected.
                    </t>
                    <t>Token transport: In MQTT CONNECT message or using the AUTH extensions for MQTT v5 described in <xref target="MQTTv5"></xref>.</t>
                </list>
            </t>
        </section>

        <section anchor="app-authzinfo" title="The authorization information endpoint">
          <t>The main document described a method for transporting tokens inside MQTT CONNECT messages.
                In this section, we describe an alternative method to transport an access token.
            </t>
            <t>
                The method consists of the MQTT broker accepting PUBLISH messages to a public "authz-info" topic. A client using this method
                MUST first
                connect to the broker, and publish the access token using the "authz-info" topic. The broker
                must verify the validity of the token (i.e., through local validation or introspection).
                After publishing the token, the client disconnects from the broker and is expected to try reconnecting over TLS.
            </t>
            <t> In MQTT v3.1, after the client published to the "authz-info" topic, it is not possible for the broker to communicate
                the result of the token
                verification. In MQTT v5, the broker can return 'Not authorized' error to a PUBLISH request for QoS greater or equal to 1.
                In any case, any  token authorization failure will affect the TLS handshake, which can prompt the client to
                obtain a valid token.
            </t>
        </section>

	<section anchor="document_updates" title="Document Updates">
	  <t>
	    Version 01 updates Version 00 as follows:
	    <list style="symbols">
	      <t>  Adds <xref target="MQTTv5"></xref> to describe improvements to the basic protocol operation with the new
		<xref target="MQTT-OASIS-Standard-v5">MQTT v5 - OASIS Specification Draft</xref>, including improved authentication
	      exchange and error reporting.</t>
	      <t> Condenses background information specific to MQTT in <xref target="basic-protocol"></xref>.</t>
	      <t> Clarifies token transport and token structure in <xref target="connect_v31"></xref>
	      and <xref target="token_validation"></xref>.</t>
	      <t>Removes Appendix on error reporting as this is now handled with MQTT v5. </t>
	    </list>
	  </t>
	  <t>
	    Version 02 updates Version 01 as follows:
	    <list style="symbols">
	      <t> Adds PINGREQ packet for token expiry checks.</t>
	      <t> Minor typo fixes. </t>
	    </list>
	  </t> 
	</section>


 <!-- Change Log

     -->

	<section anchor="Acknowledgements" title="Acknowledgements" numbered="no" toc="default">
		<t>
                The authors would like to thank Ludwig Seitz for his input on the authorization information endpoint, 
		 presented in the appendix.
              </t>		
	</section>
    </back>

</rfc>

